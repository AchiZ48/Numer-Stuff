<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Numerical Methods Calculator - Complete Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 200%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .subtitle {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .main-content {
            display: flex;
            min-height: 600px;
        }

        .sidebar {
            width: 300px;
            background: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 20px;
            border-right: 2px solid #dee2e6;
            overflow-y: auto;
            max-height: 700px;
        }

        .category {
            margin-bottom: 25px;
        }

        .category-title {
            font-weight: 600;
            color: #495057;
            margin-bottom: 10px;
            padding: 8px;
            background: linear-gradient(90deg, rgba(102,126,234,0.1) 0%, transparent 100%);
            border-radius: 5px;
            font-size: 0.95em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .method-btn {
            display: block;
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            border: none;
            background: white;
            color: #495057;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
            text-align: left;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .method-btn:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: translateX(5px);
            box-shadow: 0 4px 12px rgba(102,126,234,0.3);
        }

        .method-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(102,126,234,0.4);
        }

        .content-area {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            max-height: 700px;
        }

        .method-content {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .method-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { 
                opacity: 0;
                transform: translateY(10px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }

        .method-title {
            font-size: 2em;
            color: #667eea;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 3px solid #667eea;
        }

        .input-group {
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .input-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #495057;
            font-weight: 500;
        }

        input[type="text"], input[type="number"], select, textarea {
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 1em;
            transition: all 0.3s ease;
            background: white;
            min-width: 150px;
        }

        textarea {
            width: 100%;
            min-height: 100px;
            resize: vertical;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102,126,234,0.1);
        }

        .calculate-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102,126,234,0.3);
            margin-top: 10px;
        }

        .calculate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102,126,234,0.4);
        }

        .calculate-btn:active {
            transform: translateY(0);
        }

        .result-area {
            margin-top: 30px;
            padding: 25px;
            background: linear-gradient(135deg, rgba(102,126,234,0.05) 0%, rgba(118,75,162,0.05) 100%);
            border-radius: 10px;
            border-left: 4px solid #667eea;
            min-height: 150px;
        }

        .result-title {
            font-size: 1.3em;
            color: #667eea;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .result-content {
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            line-height: 1.8;
            color: #2d3436;
            background: white;
            padding: 15px;
            border-radius: 6px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
            overflow-x: auto;
        }

        .matrix-input {
            display: grid;
            gap: 10px;
            margin: 15px 0;
            max-width: 600px;
        }

        .matrix-row {
            display: flex;
            gap: 10px;
        }

        .matrix-cell {
            width: 70px;
            padding: 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            text-align: center;
            font-size: 0.9em;
        }

        .description {
            background: linear-gradient(135deg, rgba(102,126,234,0.05) 0%, rgba(118,75,162,0.05) 100%);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 3px solid #667eea;
            color: #495057;
            line-height: 1.6;
        }

        .welcome-message {
            text-align: center;
            padding: 50px;
            color: #6c757d;
        }

        .welcome-message h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .welcome-message p {
            font-size: 1.1em;
            line-height: 1.8;
            max-width: 600px;
            margin: 0 auto;
        }

        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 40px;
        }

        .feature-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .feature-card:hover {
            transform: translateY(-5px);
        }

        .feature-icon {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .error {
            color: #dc3545;
            padding: 10px;
            background: rgba(220,53,69,0.1);
            border-radius: 5px;
            margin-top: 10px;
        }

        .success {
            color: #28a745;
            padding: 10px;
            background: rgba(40,167,69,0.1);
            border-radius: 5px;
            margin-top: 10px;
        }

        .point-input {
            display: inline-block;
            margin: 5px;
        }

        .point-input input {
            width: 80px;
            margin: 0 5px;
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔢 Numerical Methods Calculator</h1>
            <p class="subtitle">Complete Suite of Computational Methods</p>
        </div>
        
        <div class="main-content">
            <div class="sidebar">
                <div class="category">
                    <div class="category-title">Root Finding</div>
                    <button class="method-btn" data-method="bisection">Bisection Method</button>
                    <button class="method-btn" data-method="falseposition">False Position Method</button>
                    <button class="method-btn" data-method="newtonraphson">Newton-Raphson Method</button>
                    <button class="method-btn" data-method="secant">Secant Method</button>
                    <button class="method-btn" data-method="onepoint">One-Point Iteration</button>
                    <button class="method-btn" data-method="graphical">Graphical Method</button>
                </div>
                
                <div class="category">
                    <div class="category-title">Linear Systems</div>
                    <button class="method-btn" data-method="cramer">Cramer's Rule</button>
                    <button class="method-btn" data-method="gausselim">Gauss Elimination</button>
                    <button class="method-btn" data-method="gaussjordan">Gauss-Jordan</button>
                    <button class="method-btn" data-method="matrixinv">Matrix Inversion</button>
                    <button class="method-btn" data-method="lu">LU Decomposition</button>
                    <button class="method-btn" data-method="cholesky">Cholesky Decomposition</button>
                </div>
                
                <div class="category">
                    <div class="category-title">Iterative Methods</div>
                    <button class="method-btn" data-method="jacobi">Jacobi Method</button>
                    <button class="method-btn" data-method="gaussseidel">Gauss-Seidel</button>
                    <button class="method-btn" data-method="conjugate">Conjugate Gradient</button>
                </div>
                
                <div class="category">
                    <div class="category-title">Interpolation</div>
                    <button class="method-btn" data-method="lagrange">Lagrange Interpolation</button>
                    <button class="method-btn" data-method="newtondivided">Newton Divided Difference</button>
                    <button class="method-btn" data-method="linearspline">Linear Spline</button>
                </div>
                
                <div class="category">
                    <div class="category-title">Regression</div>
                    <button class="method-btn" data-method="polynomial">Polynomial Regression</button>
                    <button class="method-btn" data-method="multilinear">Multiple Linear Regression</button>
                </div>
                
                <div class="category">
                    <div class="category-title">Integration</div>
                    <button class="method-btn" data-method="singletrap">Single Trapezoidal</button>
                    <button class="method-btn" data-method="comptrap">Composite Trapezoidal</button>
                    <button class="method-btn" data-method="simpson">Simpson's Rule</button>
                    <button class="method-btn" data-method="compsimpson">Composite Simpson's Rule</button>
                </div>
                
                <div class="category">
                    <div class="category-title">Differentiation</div>
                    <button class="method-btn" data-method="forward">Forward Divided h</button>
                    <button class="method-btn" data-method="backward">Backward Divided h</button>
                    <button class="method-btn" data-method="central">Central Divided h</button>
                    <button class="method-btn" data-method="forwardsq">Forward Divided h²</button>
                    <button class="method-btn" data-method="backwardsq">Backward Divided h²</button>
                    <button class="method-btn" data-method="centralsq">Central Divided h²</button>
                </div>
            </div>
            
            <div class="content-area" id="contentArea">
                <!-- Content will be dynamically generated here -->
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentMethod = 'welcome';
        let methodData = {};

        // Method configurations
        const methods = {
            welcome: {
                title: 'Welcome',
                content: `
                    <div class="welcome-message">
                        <h2>Welcome to Numerical Methods Calculator</h2>
                        <p>Select a method from the sidebar to begin calculating. This comprehensive tool provides implementations of all major numerical methods for solving mathematical problems.</p>
                        
                        <div class="features">
                            <div class="feature-card">
                                <div class="feature-icon">🎯</div>
                                <h3>30+ Methods</h3>
                                <p>Complete suite of numerical methods</p>
                            </div>
                            <div class="feature-card">
                                <div class="feature-icon">⚡</div>
                                <h3>Fast & Accurate</h3>
                                <p>Instant results with high precision</p>
                            </div>
                            <div class="feature-card">
                                <div class="feature-icon">📊</div>
                                <h3>Step-by-Step</h3>
                                <p>Detailed solutions with iterations</p>
                            </div>
                            <div class="feature-card">
                                <div class="feature-icon">🔍</div>
                                <h3>Comprehensive</h3>
                                <p>From root finding to integration</p>
                            </div>
                        </div>
                    </div>
                `
            },
            
            bisection: {
                title: 'Bisection Method',
                description: 'The Bisection Method is a root-finding algorithm that repeatedly bisects an interval and selects a subinterval in which a root must lie.',
                inputs: `
                    <div class="input-row">
                        <div>
                            <label>Function f(x):</label>
                            <input type="text" id="func" placeholder="x^3 - x - 2">
                        </div>
                        <div>
                            <label>Lower bound (a):</label>
                            <input type="number" id="a" placeholder="1" value="1">
                        </div>
                        <div>
                            <label>Upper bound (b):</label>
                            <input type="number" id="b" placeholder="2" value="2">
                        </div>
                        <div>
                            <label>Tolerance:</label>
                            <input type="number" id="tol" placeholder="0.0001" value="0.0001">
                        </div>
                    </div>
                `,
                calculate: calculateBisection
            },
            
            falseposition: {
                title: 'False Position Method',
                description: 'The False Position Method (Regula Falsi) is similar to the bisection method but uses a weighted average to find the root.',
                inputs: `
                    <div class="input-row">
                        <div>
                            <label>Function f(x):</label>
                            <input type="text" id="func" placeholder="x^3 - x - 2">
                        </div>
                        <div>
                            <label>Lower bound (a):</label>
                            <input type="number" id="a" placeholder="1" value="1">
                        </div>
                        <div>
                            <label>Upper bound (b):</label>
                            <input type="number" id="b" placeholder="2" value="2">
                        </div>
                        <div>
                            <label>Tolerance:</label>
                            <input type="number" id="tol" placeholder="0.0001" value="0.0001">
                        </div>
                    </div>
                `,
                calculate: calculateFalsePosition
            },
            
            newtonraphson: {
                title: 'Newton-Raphson Method',
                description: 'The Newton-Raphson method is a powerful technique for solving equations numerically using the derivative of the function.',
                inputs: `
                    <div class="input-row">
                        <div>
                            <label>Function f(x):</label>
                            <input type="text" id="func" placeholder="x^2 - 2">
                        </div>
                        <div>
                            <label>Derivative f\'(x):</label>
                            <input type="text" id="deriv" placeholder="2*x">
                        </div>
                        <div>
                            <label>Initial guess (x₀):</label>
                            <input type="number" id="x0" placeholder="1" value="1">
                        </div>
                        <div>
                            <label>Tolerance:</label>
                            <input type="number" id="tol" placeholder="0.0001" value="0.0001">
                        </div>
                    </div>
                `,
                calculate: calculateNewtonRaphson
            },
            
            secant: {
                title: 'Secant Method',
                description: 'The Secant Method is similar to Newton-Raphson but approximates the derivative using two points.',
                inputs: `
                    <div class="input-row">
                        <div>
                            <label>Function f(x):</label>
                            <input type="text" id="func" placeholder="x^2 - 2">
                        </div>
                        <div>
                            <label>First guess (x₀):</label>
                            <input type="number" id="x0" placeholder="1" value="1">
                        </div>
                        <div>
                            <label>Second guess (x₁):</label>
                            <input type="number" id="x1" placeholder="2" value="2">
                        </div>
                        <div>
                            <label>Tolerance:</label>
                            <input type="number" id="tol" placeholder="0.0001" value="0.0001">
                        </div>
                    </div>
                `,
                calculate: calculateSecant
            },
            
            onepoint: {
                title: 'One-Point Iteration',
                description: 'Fixed-point iteration method for finding roots by reformulating f(x) = 0 as x = g(x).',
                inputs: `
                    <div class="input-row">
                        <div>
                            <label>Function g(x) where x = g(x):</label>
                            <input type="text" id="func" placeholder="(2*x + 3)^(1/2)">
                        </div>
                        <div>
                            <label>Initial guess (x₀):</label>
                            <input type="number" id="x0" placeholder="4" value="4">
                        </div>
                        <div>
                            <label>Tolerance:</label>
                            <input type="number" id="tol" placeholder="0.0001" value="0.0001">
                        </div>
                    </div>
                `,
                calculate: calculateOnePoint
            },
            
            graphical: {
                title: 'Graphical Method',
                description: 'Visualize the function and estimate roots by observing where the function crosses the x-axis.',
                inputs: `
                    <div class="input-row">
                        <div>
                            <label>Function f(x):</label>
                            <input type="text" id="func" placeholder="x^2 - 4">
                        </div>
                        <div>
                            <label>X minimum:</label>
                            <input type="number" id="xmin" placeholder="-5" value="-5">
                        </div>
                        <div>
                            <label>X maximum:</label>
                            <input type="number" id="xmax" placeholder="5" value="5">
                        </div>
                        <div>
                            <label>Points:</label>
                            <input type="number" id="points" placeholder="100" value="100">
                        </div>
                    </div>
                `,
                calculate: calculateGraphical
            },
            
            cramer: {
                title: "Cramer's Rule",
                description: "Cramer's Rule solves systems of linear equations using determinants.",
                inputs: `
                    <div>
                        <label>System size (n×n):</label>
                        <input type="number" id="size" min="2" max="5" value="3" onchange="generateCramerMatrix()">
                    </div>
                    <div id="matrixContainer"></div>
                `,
                calculate: calculateCramer,
                init: () => generateCramerMatrix()
            },
            
            gausselim: {
                title: 'Gauss Elimination',
                description: 'Gauss Elimination solves systems of linear equations by transforming the augmented matrix to row echelon form.',
                inputs: `
                    <div>
                        <label>Matrix size (n×n):</label>
                        <input type="number" id="size" min="2" max="10" value="3" onchange="generateGaussMatrix()">
                    </div>
                    <div id="matrixContainer"></div>
                `,
                calculate: calculateGaussElimination,
                init: () => generateGaussMatrix()
            },
            
            gaussjordan: {
                title: 'Gauss-Jordan Method',
                description: 'Gauss-Jordan elimination reduces the matrix to reduced row echelon form.',
                inputs: `
                    <div>
                        <label>Matrix size (n×n):</label>
                        <input type="number" id="size" min="2" max="10" value="3" onchange="generateGaussJordanMatrix()">
                    </div>
                    <div id="matrixContainer"></div>
                `,
                calculate: calculateGaussJordan,
                init: () => generateGaussJordanMatrix()
            },
            
            matrixinv: {
                title: 'Matrix Inversion',
                description: 'Find the inverse of a matrix using the Gauss-Jordan method.',
                inputs: `
                    <div>
                        <label>Matrix size (n×n):</label>
                        <input type="number" id="size" min="2" max="10" value="3" onchange="generateInversionMatrix()">
                    </div>
                    <div id="matrixContainer"></div>
                `,
                calculate: calculateMatrixInversion,
                init: () => generateInversionMatrix()
            },
            
            lu: {
                title: 'LU Decomposition',
                description: 'Decompose a matrix into Lower and Upper triangular matrices.',
                inputs: `
                    <div>
                        <label>Matrix size (n×n):</label>
                        <input type="number" id="size" min="2" max="10" value="3" onchange="generateLUMatrix()">
                    </div>
                    <div id="matrixContainer"></div>
                `,
                calculate: calculateLU,
                init: () => generateLUMatrix()
            },
            
            cholesky: {
                title: 'Cholesky Decomposition',
                description: 'Decompose a positive definite symmetric matrix into L×L^T.',
                inputs: `
                    <div>
                        <label>Matrix size (n×n):</label>
                        <input type="number" id="size" min="2" max="10" value="3" onchange="generateCholeskyMatrix()">
                    </div>
                    <div id="matrixContainer"></div>
                `,
                calculate: calculateCholesky,
                init: () => generateCholeskyMatrix()
            },
            
            jacobi: {
                title: 'Jacobi Method',
                description: 'Iterative method for solving systems of linear equations.',
                inputs: `
                    <div>
                        <label>Matrix size (n×n):</label>
                        <input type="number" id="size" min="2" max="10" value="3" onchange="generateJacobiMatrix()">
                    </div>
                    <div id="matrixContainer"></div>
                    <div style="margin-top: 10px;">
                        <label>Max iterations:</label>
                        <input type="number" id="maxiter" value="100">
                        <label>Tolerance:</label>
                        <input type="number" id="tol" value="0.0001">
                    </div>
                `,
                calculate: calculateJacobi,
                init: () => generateJacobiMatrix()
            },
            
            gaussseidel: {
                title: 'Gauss-Seidel Method',
                description: 'Iterative method that uses updated values as soon as they are available.',
                inputs: `
                    <div>
                        <label>Matrix size (n×n):</label>
                        <input type="number" id="size" min="2" max="10" value="3" onchange="generateGaussSeidelMatrix()">
                    </div>
                    <div id="matrixContainer"></div>
                    <div style="margin-top: 10px;">
                        <label>Max iterations:</label>
                        <input type="number" id="maxiter" value="100">
                        <label>Tolerance:</label>
                        <input type="number" id="tol" value="0.0001">
                    </div>
                `,
                calculate: calculateGaussSeidel,
                init: () => generateGaussSeidelMatrix()
            },
            
            conjugate: {
                title: 'Conjugate Gradient Method',
                description: 'Iterative method for solving symmetric positive definite systems.',
                inputs: `
                    <div>
                        <label>Matrix size (n×n):</label>
                        <input type="number" id="size" min="2" max="10" value="3" onchange="generateConjugateMatrix()">
                    </div>
                    <div id="matrixContainer"></div>
                    <div style="margin-top: 10px;">
                        <label>Max iterations:</label>
                        <input type="number" id="maxiter" value="100">
                        <label>Tolerance:</label>
                        <input type="number" id="tol" value="0.0001">
                    </div>
                `,
                calculate: calculateConjugate,
                init: () => generateConjugateMatrix()
            },
            
            lagrange: {
                title: 'Lagrange Interpolation',
                description: 'Find a polynomial that passes through a given set of points.',
                inputs: `
                    <div>
                        <label>Number of points:</label>
                        <input type="number" id="npoints" min="2" max="10" value="3" onchange="generateLagrangeInputs()">
                    </div>
                    <div id="pointsContainer"></div>
                    <div style="margin-top: 10px;">
                        <label>Interpolate at x:</label>
                        <input type="number" id="xval" placeholder="Value to interpolate">
                    </div>
                `,
                calculate: calculateLagrange,
                init: () => generateLagrangeInputs()
            },
            
            newtondivided: {
                title: 'Newton Divided Difference',
                description: 'Interpolation using divided differences table.',
                inputs: `
                    <div>
                        <label>Number of points:</label>
                        <input type="number" id="npoints" min="2" max="10" value="3" onchange="generateNewtonDividedInputs()">
                    </div>
                    <div id="pointsContainer"></div>
                    <div style="margin-top: 10px;">
                        <label>Interpolate at x:</label>
                        <input type="number" id="xval" placeholder="Value to interpolate">
                    </div>
                `,
                calculate: calculateNewtonDivided,
                init: () => generateNewtonDividedInputs()
            },
            
            linearspline: {
                title: 'Linear Spline',
                description: 'Piecewise linear interpolation between data points.',
                inputs: `
                    <div>
                        <label>Number of points:</label>
                        <input type="number" id="npoints" min="2" max="10" value="4" onchange="generateLinearSplineInputs()">
                    </div>
                    <div id="pointsContainer"></div>
                    <div style="margin-top: 10px;">
                        <label>Interpolate at x:</label>
                        <input type="number" id="xval" placeholder="Value to interpolate">
                    </div>
                `,
                calculate: calculateLinearSpline,
                init: () => generateLinearSplineInputs()
            },
            
            polynomial: {
                title: 'Polynomial Regression',
                description: 'Fit a polynomial of specified degree to data points.',
                inputs: `
                    <div>
                        <label>Number of points:</label>
                        <input type="number" id="npoints" min="3" max="20" value="5" onchange="generatePolyRegressionInputs()">
                        <label>Polynomial degree:</label>
                        <input type="number" id="degree" min="1" max="10" value="2">
                    </div>
                    <div id="pointsContainer"></div>
                `,
                calculate: calculatePolynomialRegression,
                init: () => generatePolyRegressionInputs()
            },
            
            multilinear: {
                title: 'Multiple Linear Regression',
                description: 'Fit a linear model with multiple independent variables.',
                inputs: `
                    <div>
                        <label>Number of data points:</label>
                        <input type="number" id="npoints" min="3" max="20" value="5" onchange="generateMultiLinearInputs()">
                        <label>Number of variables:</label>
                        <input type="number" id="nvars" min="1" max="5" value="2" onchange="generateMultiLinearInputs()">
                    </div>
                    <div id="dataContainer"></div>
                `,
                calculate: calculateMultipleLinearRegression,
                init: () => generateMultiLinearInputs()
            },
            
            singletrap: {
                title: 'Single Trapezoidal Rule',
                description: 'Approximate the integral using a single trapezoid.',
                inputs: `
                    <div class="input-row">
                        <div>
                            <label>Function f(x):</label>
                            <input type="text" id="func" placeholder="x^2">
                        </div>
                        <div>
                            <label>Lower limit (a):</label>
                            <input type="number" id="a" placeholder="0" value="0">
                        </div>
                        <div>
                            <label>Upper limit (b):</label>
                            <input type="number" id="b" placeholder="1" value="1">
                        </div>
                    </div>
                `,
                calculate: calculateSingleTrapezoidal
            },
            
            comptrap: {
                title: 'Composite Trapezoidal Rule',
                description: 'Approximate the integral using multiple trapezoids.',
                inputs: `
                    <div class="input-row">
                        <div>
                            <label>Function f(x):</label>
                            <input type="text" id="func" placeholder="x^2">
                        </div>
                        <div>
                            <label>Lower limit (a):</label>
                            <input type="number" id="a" placeholder="0" value="0">
                        </div>
                        <div>
                            <label>Upper limit (b):</label>
                            <input type="number" id="b" placeholder="1" value="1">
                        </div>
                        <div>
                            <label>Number of intervals:</label>
                            <input type="number" id="n" placeholder="4" value="4" min="1">
                        </div>
                    </div>
                `,
                calculate: calculateCompositeTrapezoidal
            },
            
            simpson: {
                title: "Simpson's Rule",
                description: "Approximate the integral using parabolic segments (1/3 rule).",
                inputs: `
                    <div class="input-row">
                        <div>
                            <label>Function f(x):</label>
                            <input type="text" id="func" placeholder="x^2">
                        </div>
                        <div>
                            <label>Lower limit (a):</label>
                            <input type="number" id="a" placeholder="0" value="0">
                        </div>
                        <div>
                            <label>Upper limit (b):</label>
                            <input type="number" id="b" placeholder="1" value="1">
                        </div>
                    </div>
                `,
                calculate: calculateSimpson
            },
            
            compsimpson: {
                title: "Composite Simpson's Rule",
                description: "Approximate the integral using multiple parabolic segments.",
                inputs: `
                    <div class="input-row">
                        <div>
                            <label>Function f(x):</label>
                            <input type="text" id="func" placeholder="x^2">
                        </div>
                        <div>
                            <label>Lower limit (a):</label>
                            <input type="number" id="a" placeholder="0" value="0">
                        </div>
                        <div>
                            <label>Upper limit (b):</label>
                            <input type="number" id="b" placeholder="1" value="1">
                        </div>
                        <div>
                            <label>Number of intervals (even):</label>
                            <input type="number" id="n" placeholder="4" value="4" min="2" step="2">
                        </div>
                    </div>
                `,
                calculate: calculateCompositeSimpson
            },
            
            forward: {
                title: 'Forward Difference (First Derivative)',
                description: 'Approximate the first derivative using forward difference formula.',
                inputs: `
                    <div class="input-row">
                        <div>
                            <label>Function f(x):</label>
                            <input type="text" id="func" placeholder="x^2">
                        </div>
                        <div>
                            <label>Point x:</label>
                            <input type="number" id="x" placeholder="1" value="1">
                        </div>
                        <div>
                            <label>Step size h:</label>
                            <input type="number" id="h" placeholder="0.1" value="0.1">
                        </div>
                    </div>
                `,
                calculate: calculateForwardDifference
            },
            
            backward: {
                title: 'Backward Difference (First Derivative)',
                description: 'Approximate the first derivative using backward difference formula.',
                inputs: `
                    <div class="input-row">
                        <div>
                            <label>Function f(x):</label>
                            <input type="text" id="func" placeholder="x^2">
                        </div>
                        <div>
                            <label>Point x:</label>
                            <input type="number" id="x" placeholder="1" value="1">
                        </div>
                        <div>
                            <label>Step size h:</label>
                            <input type="number" id="h" placeholder="0.1" value="0.1">
                        </div>
                    </div>
                `,
                calculate: calculateBackwardDifference
            },
            
            central: {
                title: 'Central Difference (First Derivative)',
                description: 'Approximate the first derivative using central difference formula.',
                inputs: `
                    <div class="input-row">
                        <div>
                            <label>Function f(x):</label>
                            <input type="text" id="func" placeholder="x^2">
                        </div>
                        <div>
                            <label>Point x:</label>
                            <input type="number" id="x" placeholder="1" value="1">
                        </div>
                        <div>
                            <label>Step size h:</label>
                            <input type="number" id="h" placeholder="0.1" value="0.1">
                        </div>
                    </div>
                `,
                calculate: calculateCentralDifference
            },
            
            forwardsq: {
                title: 'Forward Difference (Second Derivative)',
                description: 'Approximate the second derivative using forward difference formula.',
                inputs: `
                    <div class="input-row">
                        <div>
                            <label>Function f(x):</label>
                            <input type="text" id="func" placeholder="x^3">
                        </div>
                        <div>
                            <label>Point x:</label>
                            <input type="number" id="x" placeholder="1" value="1">
                        </div>
                        <div>
                            <label>Step size h:</label>
                            <input type="number" id="h" placeholder="0.1" value="0.1">
                        </div>
                    </div>
                `,
                calculate: calculateForwardDifferenceSecond
            },
            
            backwardsq: {
                title: 'Backward Difference (Second Derivative)',
                description: 'Approximate the second derivative using backward difference formula.',
                inputs: `
                    <div class="input-row">
                        <div>
                            <label>Function f(x):</label>
                            <input type="text" id="func" placeholder="x^3">
                        </div>
                        <div>
                            <label>Point x:</label>
                            <input type="number" id="x" placeholder="1" value="1">
                        </div>
                        <div>
                            <label>Step size h:</label>
                            <input type="number" id="h" placeholder="0.1" value="0.1">
                        </div>
                    </div>
                `,
                calculate: calculateBackwardDifferenceSecond
            },
            
            centralsq: {
                title: 'Central Difference (Second Derivative)',
                description: 'Approximate the second derivative using central difference formula.',
                inputs: `
                    <div class="input-row">
                        <div>
                            <label>Function f(x):</label>
                            <input type="text" id="func" placeholder="x^3">
                        </div>
                        <div>
                            <label>Point x:</label>
                            <input type="number" id="x" placeholder="1" value="1">
                        </div>
                        <div>
                            <label>Step size h:</label>
                            <input type="number" id="h" placeholder="0.1" value="0.1">
                        </div>
                    </div>
                `,
                calculate: calculateCentralDifferenceSecond
            }
        };

        // Utility Functions
        function evaluateFunction(expr, x) {
            let expression = expr.replace(/\^/g, '**')
                                .replace(/sin/g, 'Math.sin')
                                .replace(/cos/g, 'Math.cos')
                                .replace(/tan/g, 'Math.tan')
                                .replace(/log/g, 'Math.log')
                                .replace(/ln/g, 'Math.log')
                                .replace(/exp/g, 'Math.exp')
                                .replace(/sqrt/g, 'Math.sqrt')
                                .replace(/abs/g, 'Math.abs')
                                .replace(/pi/g, 'Math.PI')
                                .replace(/e(?![xp])/g, 'Math.E');
            
            // Replace all x with the value
            expression = expression.replace(/x/g, `(${x})`);
            
            try {
                return Function('"use strict"; return (' + expression + ')')();
            } catch (e) {
                throw new Error('Invalid function expression');
            }
        }

        // Root Finding Methods
        function calculateBisection() {
            const func = document.getElementById('func').value;
            const a = parseFloat(document.getElementById('a').value);
            const b = parseFloat(document.getElementById('b').value);
            const tol = parseFloat(document.getElementById('tol').value);
            
            if (!func || isNaN(a) || isNaN(b) || isNaN(tol)) {
                showResult('<span class="error">Please fill all fields</span>');
                return;
            }
            
            let result = "Iteration | a | b | c | f(c) | Error\n";
            result += "---------|---|---|---|------|------\n";
            
            let iter = 0;
            let aVal = a, bVal = b;
            
            try {
                const fa = evaluateFunction(func, aVal);
                const fb = evaluateFunction(func, bVal);
                
                if (fa * fb > 0) {
                    showResult('<span class="error">Function must have opposite signs at boundaries</span>');
                    return;
                }
                
                let c, fc, error;
                do {
                    c = (aVal + bVal) / 2;
                    fc = evaluateFunction(func, c);
                    error = Math.abs(bVal - aVal) / 2;
                    
                    result += `${iter.toString().padStart(9)} | ${aVal.toFixed(6)} | ${bVal.toFixed(6)} | ${c.toFixed(6)} | ${fc.toFixed(6)} | ${error.toFixed(6)}\n`;
                    
                    if (evaluateFunction(func, aVal) * fc < 0) {
                        bVal = c;
                    } else {
                        aVal = c;
                    }
                    
                    iter++;
                    if (iter > 100) break;
                } while (error > tol);
                
                result += `\n✓ Root found: x = ${c.toFixed(8)}\n`;
                result += `✓ f(x) = ${fc.toFixed(8)}\n`;
                result += `✓ Iterations: ${iter}`;
                
                showResult(result);
            } catch (e) {
                showResult('<span class="error">Error: ' + e.message + '</span>');
            }
        }

        function calculateFalsePosition() {
            const func = document.getElementById('func').value;
            const a = parseFloat(document.getElementById('a').value);
            const b = parseFloat(document.getElementById('b').value);
            const tol = parseFloat(document.getElementById('tol').value);
            
            if (!func || isNaN(a) || isNaN(b) || isNaN(tol)) {
                showResult('<span class="error">Please fill all fields</span>');
                return;
            }
            
            let result = "Iteration | a | b | c | f(c) | Error\n";
            result += "---------|---|---|---|------|------\n";
            
            let iter = 0;
            let aVal = a, bVal = b, cOld = 0;
            
            try {
                const fa = evaluateFunction(func, aVal);
                const fb = evaluateFunction(func, bVal);
                
                if (fa * fb > 0) {
                    showResult('<span class="error">Function must have opposite signs at boundaries</span>');
                    return;
                }
                
                let c, fc, error;
                do {
                    const faNew = evaluateFunction(func, aVal);
                    const fbNew = evaluateFunction(func, bVal);
                    
                    c = (aVal * fbNew - bVal * faNew) / (fbNew - faNew);
                    fc = evaluateFunction(func, c);
                    error = Math.abs(c - cOld);
                    
                    result += `${iter.toString().padStart(9)} | ${aVal.toFixed(6)} | ${bVal.toFixed(6)} | ${c.toFixed(6)} | ${fc.toFixed(6)} | ${error.toFixed(6)}\n`;
                    
                    if (faNew * fc < 0) {
                        bVal = c;
                    } else {
                        aVal = c;
                    }
                    
                    cOld = c;
                    iter++;
                    if (iter > 100) break;
                } while (error > tol && iter > 1);
                
                result += `\n✓ Root found: x = ${c.toFixed(8)}\n`;
                result += `✓ f(x) = ${fc.toFixed(8)}\n`;
                result += `✓ Iterations: ${iter}`;
                
                showResult(result);
            } catch (e) {
                showResult('<span class="error">Error: ' + e.message + '</span>');
            }
        }

        function calculateNewtonRaphson() {
            const func = document.getElementById('func').value;
            const deriv = document.getElementById('deriv').value;
            const x0 = parseFloat(document.getElementById('x0').value);
            const tol = parseFloat(document.getElementById('tol').value);
            
            if (!func || !deriv || isNaN(x0) || isNaN(tol)) {
                showResult('<span class="error">Please fill all fields</span>');
                return;
            }
            
            let result = "Iteration | x | f(x) | f'(x) | Error\n";
            result += "----------|---|-------|-------|------\n";
            
            let iter = 0;
            let x = x0;
            
            try {
                let error;
                do {
                    const fx = evaluateFunction(func, x);
                    const fpx = evaluateFunction(deriv, x);
                    
                    if (Math.abs(fpx) < 1e-10) {
                        result += "\n⚠️ Derivative too small";
                        break;
                    }
                    
                    const xNew = x - fx / fpx;
                    error = Math.abs(xNew - x);
                    
                    result += `${iter.toString().padStart(9)} | ${x.toFixed(6)} | ${fx.toFixed(6)} | ${fpx.toFixed(6)} | ${error.toFixed(6)}\n`;
                    
                    x = xNew;
                    iter++;
                    if (iter > 100) break;
                } while (error > tol);
                
                result += `\n✓ Root found: x = ${x.toFixed(8)}\n`;
                result += `✓ Iterations: ${iter}`;
                
                showResult(result);
            } catch (e) {
                showResult('<span class="error">Error: ' + e.message + '</span>');
            }
        }

        function calculateSecant() {
            const func = document.getElementById('func').value;
            const x0 = parseFloat(document.getElementById('x0').value);
            const x1 = parseFloat(document.getElementById('x1').value);
            const tol = parseFloat(document.getElementById('tol').value);
            
            if (!func || isNaN(x0) || isNaN(x1) || isNaN(tol)) {
                showResult('<span class="error">Please fill all fields</span>');
                return;
            }
            
            let result = "Iteration | x_{n-1} | x_n | f(x_n) | Error\n";
            result += "----------|---------|-----|--------|------\n";
            
            let iter = 0;
            let xPrev = x0, xCurr = x1;
            
            try {
                let error;
                do {
                    const fPrev = evaluateFunction(func, xPrev);
                    const fCurr = evaluateFunction(func, xCurr);
                    
                    if (Math.abs(fCurr - fPrev) < 1e-10) {
                        result += "\n⚠️ Division by zero";
                        break;
                    }
                    
                    const xNext = xCurr - fCurr * (xCurr - xPrev) / (fCurr - fPrev);
                    error = Math.abs(xNext - xCurr);
                    
                    result += `${iter.toString().padStart(9)} | ${xPrev.toFixed(6)} | ${xCurr.toFixed(6)} | ${fCurr.toFixed(6)} | ${error.toFixed(6)}\n`;
                    
                    xPrev = xCurr;
                    xCurr = xNext;
                    iter++;
                    if (iter > 100) break;
                } while (error > tol);
                
                result += `\n✓ Root found: x = ${xCurr.toFixed(8)}\n`;
                result += `✓ Iterations: ${iter}`;
                
                showResult(result);
            } catch (e) {
                showResult('<span class="error">Error: ' + e.message + '</span>');
            }
        }

        function calculateOnePoint() {
            const func = document.getElementById('func').value;
            const x0 = parseFloat(document.getElementById('x0').value);
            const tol = parseFloat(document.getElementById('tol').value);
            
            if (!func || isNaN(x0) || isNaN(tol)) {
                showResult('<span class="error">Please fill all fields</span>');
                return;
            }
            
            let result = "Iteration | x | g(x) | Error\n";
            result += "----------|---|------|------\n";
            
            let iter = 0;
            let x = x0;
            
            try {
                let error;
                do {
                    const xNew = evaluateFunction(func, x);
                    error = Math.abs(xNew - x);
                    
                    result += `${iter.toString().padStart(9)} | ${x.toFixed(6)} | ${xNew.toFixed(6)} | ${error.toFixed(6)}\n`;
                    
                    x = xNew;
                    iter++;
                    if (iter > 100) break;
                } while (error > tol);
                
                result += `\n✓ Fixed point found: x = ${x.toFixed(8)}\n`;
                result += `✓ Iterations: ${iter}`;
                
                showResult(result);
            } catch (e) {
                showResult('<span class="error">Error: ' + e.message + '</span>');
            }
        }

        function calculateGraphical() {
            const func = document.getElementById('func').value;
            const xmin = parseFloat(document.getElementById('xmin').value);
            const xmax = parseFloat(document.getElementById('xmax').value);
            const points = parseInt(document.getElementById('points').value);
            
            if (!func || isNaN(xmin) || isNaN(xmax) || isNaN(points)) {
                showResult('<span class="error">Please fill all fields</span>');
                return;
            }
            
            const step = (xmax - xmin) / points;
            let result = "Graphical Analysis of f(x) = " + func + "\n\n";
            result += "x values where f(x) is close to zero:\n\n";
            result += "x | f(x)\n";
            result += "--|-----\n";
            
            let roots = [];
            let prevSign = null;
            
            try {
                for (let i = 0; i <= points; i++) {
                    const x = xmin + i * step;
                    const y = evaluateFunction(func, x);
                    
                    if (Math.abs(y) < 0.01) {
                        result += `${x.toFixed(4)} | ${y.toFixed(6)} ← Near zero\n`;
                        roots.push(x);
                    }
                    
                    const currentSign = Math.sign(y);
                    if (prevSign !== null && prevSign !== currentSign && currentSign !== 0) {
                        const xRoot = x - step/2;
                        result += `${xRoot.toFixed(4)} | Sign change detected\n`;
                        roots.push(xRoot);
                    }
                    prevSign = currentSign;
                }
                
                result += "\n✓ Analysis complete\n";
                if (roots.length > 0) {
                    result += "✓ Approximate roots found near: " + roots.map(r => r.toFixed(4)).join(", ");
                } else {
                    result += "✓ No roots detected in the given interval";
                }
                
                showResult(result);
            } catch (e) {
                showResult('<span class="error">Error: ' + e.message + '</span>');
            }
        }

        // Matrix generation functions
        function generateCramerMatrix() {
            const n = parseInt(document.getElementById('size').value);
            let html = '<label>System [A][x] = [b]:</label><div class="matrix-input">';
            
            for (let i = 0; i < n; i++) {
                html += '<div class="matrix-row">';
                for (let j = 0; j <= n; j++) {
                    const id = j < n ? `a${i}-${j}` : `b${i}`;
                    const placeholder = j < n ? `a${i+1}${j+1}` : `b${i+1}`;
                    html += `<input type="number" class="matrix-cell" id="${id}" placeholder="${placeholder}">`;
                }
                html += '</div>';
            }
            html += '</div>';
            
            document.getElementById('matrixContainer').innerHTML = html;
        }

        function generateGaussMatrix() {
            generateCramerMatrix(); // Same structure
        }

        function generateGaussJordanMatrix() {
            generateCramerMatrix(); // Same structure
        }

        function generateInversionMatrix() {
            const n = parseInt(document.getElementById('size').value);
            let html = '<label>Matrix A:</label><div class="matrix-input">';
            
            for (let i = 0; i < n; i++) {
                html += '<div class="matrix-row">';
                for (let j = 0; j < n; j++) {
                    html += `<input type="number" class="matrix-cell" id="a${i}-${j}" placeholder="a${i+1}${j+1}">`;
                }
                html += '</div>';
            }
            html += '</div>';
            
            document.getElementById('matrixContainer').innerHTML = html;
        }

        function generateLUMatrix() {
            generateCramerMatrix(); // Include b vector
        }

        function generateCholeskyMatrix() {
            generateCramerMatrix(); // Include b vector
        }

        function generateJacobiMatrix() {
            generateCramerMatrix(); // Same structure
        }

        function generateGaussSeidelMatrix() {
            generateCramerMatrix(); // Same structure
        }

        function generateConjugateMatrix() {
            generateCramerMatrix(); // Same structure
        }

        function generateLagrangeInputs() {
            const n = parseInt(document.getElementById('npoints').value);
            let html = '<label>Data Points:</label><div>';
            
            for (let i = 0; i < n; i++) {
                html += `<div class="point-input">
                    Point ${i+1}: 
                    x<sub>${i}</sub> = <input type="number" id="x${i}" placeholder="x${i}">
                    y<sub>${i}</sub> = <input type="number" id="y${i}" placeholder="y${i}">
                </div>`;
            }
            html += '</div>';
            
            document.getElementById('pointsContainer').innerHTML = html;
        }

        function generateNewtonDividedInputs() {
            generateLagrangeInputs(); // Same structure
        }

        function generateLinearSplineInputs() {
            generateLagrangeInputs(); // Same structure
        }

        function generatePolyRegressionInputs() {
            generateLagrangeInputs(); // Same structure
        }

        function generateMultiLinearInputs() {
            const n = parseInt(document.getElementById('npoints').value);
            const vars = parseInt(document.getElementById('nvars').value);
            
            let html = '<label>Data Points:</label><div style="overflow-x: auto;"><table><tr><th>Point</th>';
            
            for (let j = 0; j < vars; j++) {
                html += `<th>x<sub>${j+1}</sub></th>`;
            }
            html += '<th>y</th></tr>';
            
            for (let i = 0; i < n; i++) {
                html += `<tr><td>${i+1}</td>`;
                for (let j = 0; j < vars; j++) {
                    html += `<td><input type="number" id="x${i}-${j}" style="width: 60px;"></td>`;
                }
                html += `<td><input type="number" id="y${i}" style="width: 60px;"></td></tr>`;
            }
            html += '</table></div>';
            
            document.getElementById('dataContainer').innerHTML = html;
        }

        // Linear System Methods
        function calculateCramer() {
            const n = parseInt(document.getElementById('size').value);
            const A = [], b = [];
            
            for (let i = 0; i < n; i++) {
                A[i] = [];
                for (let j = 0; j < n; j++) {
                    A[i][j] = parseFloat(document.getElementById(`a${i}-${j}`).value) || 0;
                }
                b[i] = parseFloat(document.getElementById(`b${i}`).value) || 0;
            }
            
            const det = determinant(A);
            if (Math.abs(det) < 1e-10) {
                showResult('<span class="error">System is singular (determinant = 0)</span>');
                return;
            }
            
            let result = "Cramer's Rule Solution\n\n";
            result += `Determinant of A = ${det.toFixed(6)}\n\n`;
            
            const x = [];
            for (let i = 0; i < n; i++) {
                const Ai = JSON.parse(JSON.stringify(A));
                for (let j = 0; j < n; j++) {
                    Ai[j][i] = b[j];
                }
                x[i] = determinant(Ai) / det;
                result += `x${i+1} = ${x[i].toFixed(6)}\n`;
            }
            
            showResult(result);
        }

        function calculateGaussElimination() {
            const n = parseInt(document.getElementById('size').value);
            const A = [], b = [];
            
            for (let i = 0; i < n; i++) {
                A[i] = [];
                for (let j = 0; j < n; j++) {
                    A[i][j] = parseFloat(document.getElementById(`a${i}-${j}`).value) || 0;
                }
                b[i] = parseFloat(document.getElementById(`b${i}`).value) || 0;
            }
            
            let result = "Gauss Elimination Method\n\n";
            
            // Forward elimination
            for (let k = 0; k < n - 1; k++) {
                // Partial pivoting
                let maxRow = k;
                for (let i = k + 1; i < n; i++) {
                    if (Math.abs(A[i][k]) > Math.abs(A[maxRow][k])) {
                        maxRow = i;
                    }
                }
                
                if (maxRow !== k) {
                    [A[k], A[maxRow]] = [A[maxRow], A[k]];
                    [b[k], b[maxRow]] = [b[maxRow], b[k]];
                    result += `Swapped row ${k+1} with row ${maxRow+1}\n`;
                }
                
                for (let i = k + 1; i < n; i++) {
                    const factor = A[i][k] / A[k][k];
                    for (let j = k; j < n; j++) {
                        A[i][j] -= factor * A[k][j];
                    }
                    b[i] -= factor * b[k];
                }
            }
            
            // Back substitution
            const x = new Array(n);
            for (let i = n - 1; i >= 0; i--) {
                let sum = 0;
                for (let j = i + 1; j < n; j++) {
                    sum += A[i][j] * x[j];
                }
                x[i] = (b[i] - sum) / A[i][i];
            }
            
            result += "\nSolution:\n";
            for (let i = 0; i < n; i++) {
                result += `x${i+1} = ${x[i].toFixed(6)}\n`;
            }
            
            showResult(result);
        }

        function calculateGaussJordan() {
            const n = parseInt(document.getElementById('size').value);
            const A = [], b = [];
            
            for (let i = 0; i < n; i++) {
                A[i] = [];
                for (let j = 0; j < n; j++) {
                    A[i][j] = parseFloat(document.getElementById(`a${i}-${j}`).value) || 0;
                }
                b[i] = parseFloat(document.getElementById(`b${i}`).value) || 0;
            }
            
            let result = "Gauss-Jordan Elimination\n\n";
            
            // Forward elimination and backward elimination
            for (let k = 0; k < n; k++) {
                // Partial pivoting
                let maxRow = k;
                for (let i = k + 1; i < n; i++) {
                    if (Math.abs(A[i][k]) > Math.abs(A[maxRow][k])) {
                        maxRow = i;
                    }
                }
                
                if (maxRow !== k) {
                    [A[k], A[maxRow]] = [A[maxRow], A[k]];
                    [b[k], b[maxRow]] = [b[maxRow], b[k]];
                }
                
                // Scale pivot row
                const pivot = A[k][k];
                for (let j = k; j < n; j++) {
                    A[k][j] /= pivot;
                }
                b[k] /= pivot;
                
                // Eliminate column
                for (let i = 0; i < n; i++) {
                    if (i !== k) {
                        const factor = A[i][k];
                        for (let j = k; j < n; j++) {
                            A[i][j] -= factor * A[k][j];
                        }
                        b[i] -= factor * b[k];
                    }
                }
            }
            
            result += "Solution:\n";
            for (let i = 0; i < n; i++) {
                result += `x${i+1} = ${b[i].toFixed(6)}\n`;
            }
            
            showResult(result);
        }

        function calculateMatrixInversion() {
            const n = parseInt(document.getElementById('size').value);
            const A = [], Aug = [];
            
            for (let i = 0; i < n; i++) {
                A[i] = [];
                Aug[i] = [];
                for (let j = 0; j < n; j++) {
                    A[i][j] = parseFloat(document.getElementById(`a${i}-${j}`).value) || 0;
                    Aug[i][j] = A[i][j];
                }
                for (let j = 0; j < n; j++) {
                    Aug[i][n + j] = i === j ? 1 : 0;
                }
            }
            
            let result = "Matrix Inversion using Gauss-Jordan\n\n";
            
            // Gauss-Jordan on augmented matrix
            for (let k = 0; k < n; k++) {
                // Find pivot
                let maxRow = k;
                for (let i = k + 1; i < n; i++) {
                    if (Math.abs(Aug[i][k]) > Math.abs(Aug[maxRow][k])) {
                        maxRow = i;
                    }
                }
                
                if (Math.abs(Aug[maxRow][k]) < 1e-10) {
                    showResult('<span class="error">Matrix is singular</span>');
                    return;
                }
                
                [Aug[k], Aug[maxRow]] = [Aug[maxRow], Aug[k]];
                
                // Scale row
                const pivot = Aug[k][k];
                for (let j = 0; j < 2 * n; j++) {
                    Aug[k][j] /= pivot;
                }
                
                // Eliminate column
                for (let i = 0; i < n; i++) {
                    if (i !== k) {
                        const factor = Aug[i][k];
                        for (let j = 0; j < 2 * n; j++) {
                            Aug[i][j] -= factor * Aug[k][j];
                        }
                    }
                }
            }
            
            result += "Inverse Matrix:\n";
            for (let i = 0; i < n; i++) {
                result += "[ ";
                for (let j = 0; j < n; j++) {
                    result += Aug[i][n + j].toFixed(4) + " ";
                }
                result += "]\n";
            }
            
            showResult(result);
        }

        function calculateLU() {
            const n = parseInt(document.getElementById('size').value);
            const A = [], b = [];
            
            for (let i = 0; i < n; i++) {
                A[i] = [];
                for (let j = 0; j < n; j++) {
                    A[i][j] = parseFloat(document.getElementById(`a${i}-${j}`).value) || 0;
                }
                b[i] = parseFloat(document.getElementById(`b${i}`).value) || 0;
            }
            
            const L = [], U = [];
            for (let i = 0; i < n; i++) {
                L[i] = new Array(n).fill(0);
                U[i] = new Array(n).fill(0);
                L[i][i] = 1;
            }
            
            // Doolittle decomposition
            for (let i = 0; i < n; i++) {
                // Upper triangular
                for (let k = i; k < n; k++) {
                    let sum = 0;
                    for (let j = 0; j < i; j++) {
                        sum += L[i][j] * U[j][k];
                    }
                    U[i][k] = A[i][k] - sum;
                }
                
                // Lower triangular
                for (let k = i + 1; k < n; k++) {
                    let sum = 0;
                    for (let j = 0; j < i; j++) {
                        sum += L[k][j] * U[j][i];
                    }
                    L[k][i] = (A[k][i] - sum) / U[i][i];
                }
            }
            
            let result = "LU Decomposition\n\nL Matrix:\n";
            for (let i = 0; i < n; i++) {
                result += "[ ";
                for (let j = 0; j < n; j++) {
                    result += L[i][j].toFixed(4) + " ";
                }
                result += "]\n";
            }
            
            result += "\nU Matrix:\n";
            for (let i = 0; i < n; i++) {
                result += "[ ";
                for (let j = 0; j < n; j++) {
                    result += U[i][j].toFixed(4) + " ";
                }
                result += "]\n";
            }
            
            // Forward substitution for Ly = b
            const y = new Array(n);
            for (let i = 0; i < n; i++) {
                let sum = 0;
                for (let j = 0; j < i; j++) {
                    sum += L[i][j] * y[j];
                }
                y[i] = b[i] - sum;
            }
            
            // Back substitution for Ux = y
            const x = new Array(n);
            for (let i = n - 1; i >= 0; i--) {
                let sum = 0;
                for (let j = i + 1; j < n; j++) {
                    sum += U[i][j] * x[j];
                }
                x[i] = (y[i] - sum) / U[i][i];
            }
            
            result += "\nSolution:\n";
            for (let i = 0; i < n; i++) {
                result += `x${i+1} = ${x[i].toFixed(6)}\n`;
            }
            
            showResult(result);
        }

        function calculateCholesky() {
            const n = parseInt(document.getElementById('size').value);
            const A = [], b = [];
            
            for (let i = 0; i < n; i++) {
                A[i] = [];
                for (let j = 0; j < n; j++) {
                    A[i][j] = parseFloat(document.getElementById(`a${i}-${j}`).value) || 0;
                }
                b[i] = parseFloat(document.getElementById(`b${i}`).value) || 0;
            }
            
            // Check symmetry
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    if (Math.abs(A[i][j] - A[j][i]) > 1e-10) {
                        showResult('<span class="error">Matrix must be symmetric</span>');
                        return;
                    }
                }
            }
            
            const L = [];
            for (let i = 0; i < n; i++) {
                L[i] = new Array(n).fill(0);
            }
            
            // Cholesky decomposition
            for (let i = 0; i < n; i++) {
                for (let j = 0; j <= i; j++) {
                    let sum = 0;
                    
                    if (i === j) {
                        for (let k = 0; k < j; k++) {
                            sum += L[j][k] * L[j][k];
                        }
                        const val = A[j][j] - sum;
                        if (val < 0) {
                            showResult('<span class="error">Matrix is not positive definite</span>');
                            return;
                        }
                        L[j][j] = Math.sqrt(val);
                    } else {
                        for (let k = 0; k < j; k++) {
                            sum += L[i][k] * L[j][k];
                        }
                        L[i][j] = (A[i][j] - sum) / L[j][j];
                    }
                }
            }
            
            let result = "Cholesky Decomposition\n\nL Matrix:\n";
            for (let i = 0; i < n; i++) {
                result += "[ ";
                for (let j = 0; j < n; j++) {
                    result += L[i][j].toFixed(4) + " ";
                }
                result += "]\n";
            }
            
            // Solve Ly = b
            const y = new Array(n);
            for (let i = 0; i < n; i++) {
                let sum = 0;
                for (let j = 0; j < i; j++) {
                    sum += L[i][j] * y[j];
                }
                y[i] = (b[i] - sum) / L[i][i];
            }
            
            // Solve L^T x = y
            const x = new Array(n);
            for (let i = n - 1; i >= 0; i--) {
                let sum = 0;
                for (let j = i + 1; j < n; j++) {
                    sum += L[j][i] * x[j];
                }
                x[i] = (y[i] - sum) / L[i][i];
            }
            
            result += "\nSolution:\n";
            for (let i = 0; i < n; i++) {
                result += `x${i+1} = ${x[i].toFixed(6)}\n`;
            }
            
            showResult(result);
        }

        // Iterative Methods
        function calculateJacobi() {
            const n = parseInt(document.getElementById('size').value);
            const maxIter = parseInt(document.getElementById('maxiter').value) || 100;
            const tol = parseFloat(document.getElementById('tol').value) || 0.0001;
            
            const A = [], b = [];
            for (let i = 0; i < n; i++) {
                A[i] = [];
                for (let j = 0; j < n; j++) {
                    A[i][j] = parseFloat(document.getElementById(`a${i}-${j}`).value) || 0;
                }
                b[i] = parseFloat(document.getElementById(`b${i}`).value) || 0;
            }
            
            let x = new Array(n).fill(0);
            let xNew = new Array(n);
            let result = "Jacobi Iteration Method\n\n";
            
            for (let iter = 0; iter < maxIter; iter++) {
                let maxError = 0;
                
                for (let i = 0; i < n; i++) {
                    let sum = 0;
                    for (let j = 0; j < n; j++) {
                        if (i !== j) {
                            sum += A[i][j] * x[j];
                        }
                    }
                    xNew[i] = (b[i] - sum) / A[i][i];
                    maxError = Math.max(maxError, Math.abs(xNew[i] - x[i]));
                }
                
                x = [...xNew];
                
                if (iter < 5 || maxError < tol) {
                    result += `Iteration ${iter + 1}: `;
                    for (let i = 0; i < n; i++) {
                        result += `x${i+1}=${x[i].toFixed(6)} `;
                    }
                    result += `Error=${maxError.toFixed(6)}\n`;
                }
                
                if (maxError < tol) {
                    result += `\n✓ Converged after ${iter + 1} iterations\n`;
                    break;
                }
            }
            
            result += "\nFinal Solution:\n";
            for (let i = 0; i < n; i++) {
                result += `x${i+1} = ${x[i].toFixed(6)}\n`;
            }
            
            showResult(result);
        }

        function calculateGaussSeidel() {
            const n = parseInt(document.getElementById('size').value);
            const maxIter = parseInt(document.getElementById('maxiter').value) || 100;
            const tol = parseFloat(document.getElementById('tol').value) || 0.0001;
            
            const A = [], b = [];
            for (let i = 0; i < n; i++) {
                A[i] = [];
                for (let j = 0; j < n; j++) {
                    A[i][j] = parseFloat(document.getElementById(`a${i}-${j}`).value) || 0;
                }
                b[i] = parseFloat(document.getElementById(`b${i}`).value) || 0;
            }
            
            let x = new Array(n).fill(0);
            let result = "Gauss-Seidel Method\n\n";
            
            for (let iter = 0; iter < maxIter; iter++) {
                let maxError = 0;
                
                for (let i = 0; i < n; i++) {
                    let sum = 0;
                    for (let j = 0; j < n; j++) {
                        if (i !== j) {
                            sum += A[i][j] * x[j];
                        }
                    }
                    const xOld = x[i];
                    x[i] = (b[i] - sum) / A[i][i];
                    maxError = Math.max(maxError, Math.abs(x[i] - xOld));
                }
                
                if (iter < 5 || maxError < tol) {
                    result += `Iteration ${iter + 1}: `;
                    for (let i = 0; i < n; i++) {
                        result += `x${i+1}=${x[i].toFixed(6)} `;
                    }
                    result += `Error=${maxError.toFixed(6)}\n`;
                }
                
                if (maxError < tol) {
                    result += `\n✓ Converged after ${iter + 1} iterations\n`;
                    break;
                }
            }
            
            result += "\nFinal Solution:\n";
            for (let i = 0; i < n; i++) {
                result += `x${i+1} = ${x[i].toFixed(6)}\n`;
            }
            
            showResult(result);
        }

        function calculateConjugate() {
            const n = parseInt(document.getElementById('size').value);
            const maxIter = parseInt(document.getElementById('maxiter').value) || 100;
            const tol = parseFloat(document.getElementById('tol').value) || 0.0001;
            
            const A = [], b = [];
            for (let i = 0; i < n; i++) {
                A[i] = [];
                for (let j = 0; j < n; j++) {
                    A[i][j] = parseFloat(document.getElementById(`a${i}-${j}`).value) || 0;
                }
                b[i] = parseFloat(document.getElementById(`b${i}`).value) || 0;
            }
            
            let x = new Array(n).fill(0);
            let r = [...b]; // r = b - Ax, but x = 0 initially
            let p = [...r];
            let rsold = dotProduct(r, r);
            
            let result = "Conjugate Gradient Method\n\n";
            
            for (let iter = 0; iter < maxIter; iter++) {
                const Ap = matrixVectorMultiply(A, p);
                const alpha = rsold / dotProduct(p, Ap);
                
                for (let i = 0; i < n; i++) {
                    x[i] += alpha * p[i];
                    r[i] -= alpha * Ap[i];
                }
                
                const rsnew = dotProduct(r, r);
                
                if (Math.sqrt(rsnew) < tol) {
                    result += `\n✓ Converged after ${iter + 1} iterations\n`;
                    break;
                }
                
                const beta = rsnew / rsold;
                for (let i = 0; i < n; i++) {
                    p[i] = r[i] + beta * p[i];
                }
                
                rsold = rsnew;
                
                if (iter < 5) {
                    result += `Iteration ${iter + 1}: Residual = ${Math.sqrt(rsnew).toFixed(6)}\n`;
                }
            }
            
            result += "\nFinal Solution:\n";
            for (let i = 0; i < n; i++) {
                result += `x${i+1} = ${x[i].toFixed(6)}\n`;
            }
            
            showResult(result);
        }

        // Interpolation Methods
        function calculateLagrange() {
            const n = parseInt(document.getElementById('npoints').value);
            const xVal = parseFloat(document.getElementById('xval').value);
            
            const x = [], y = [];
            for (let i = 0; i < n; i++) {
                x[i] = parseFloat(document.getElementById(`x${i}`).value);
                y[i] = parseFloat(document.getElementById(`y${i}`).value);
                if (isNaN(x[i]) || isNaN(y[i])) {
                    showResult('<span class="error">Please fill all points</span>');
                    return;
                }
            }
            
            if (isNaN(xVal)) {
                showResult('<span class="error">Please enter interpolation point</span>');
                return;
            }
            
            let result = "Lagrange Interpolation\n\n";
            let yVal = 0;
            
            for (let i = 0; i < n; i++) {
                let L = 1;
                let terms = [];
                
                for (let j = 0; j < n; j++) {
                    if (i !== j) {
                        L *= (xVal - x[j]) / (x[i] - x[j]);
                        terms.push(`(x - ${x[j]})/(${x[i]} - ${x[j]})`);
                    }
                }
                
                result += `L${i}(x) = ${terms.join(' × ')}\n`;
                result += `L${i}(${xVal}) = ${L.toFixed(6)}\n\n`;
                
                yVal += y[i] * L;
            }
            
            result += `✓ P(${xVal}) = ${yVal.toFixed(6)}`;
            
            showResult(result);
        }

        function calculateNewtonDivided() {
            const n = parseInt(document.getElementById('npoints').value);
            const xVal = parseFloat(document.getElementById('xval').value);
            
            const x = [], y = [];
            for (let i = 0; i < n; i++) {
                x[i] = parseFloat(document.getElementById(`x${i}`).value);
                y[i] = parseFloat(document.getElementById(`y${i}`).value);
                if (isNaN(x[i]) || isNaN(y[i])) {
                    showResult('<span class="error">Please fill all points</span>');
                    return;
                }
            }
            
            if (isNaN(xVal)) {
                showResult('<span class="error">Please enter interpolation point</span>');
                return;
            }
            
            // Create divided difference table
            const table = [];
            for (let i = 0; i < n; i++) {
                table[i] = new Array(n);
                table[i][0] = y[i];
            }
            
            for (let j = 1; j < n; j++) {
                for (let i = 0; i < n - j; i++) {
                    table[i][j] = (table[i + 1][j - 1] - table[i][j - 1]) / (x[i + j] - x[i]);
                }
            }
            
            let result = "Newton Divided Difference\n\nDivided Difference Table:\n";
            for (let i = 0; i < n; i++) {
                result += `f[x${i}] = ${table[i][0].toFixed(6)}\n`;
            }
            
            // Calculate interpolated value
            let yVal = table[0][0];
            let product = 1;
            
            for (let i = 1; i < n; i++) {
                product *= (xVal - x[i - 1]);
                yVal += table[0][i] * product;
            }
            
            result += `\n✓ P(${xVal}) = ${yVal.toFixed(6)}`;
            
            showResult(result);
        }

        function calculateLinearSpline() {
            const n = parseInt(document.getElementById('npoints').value);
            const xVal = parseFloat(document.getElementById('xval').value);
            
            const x = [], y = [];
            for (let i = 0; i < n; i++) {
                x[i] = parseFloat(document.getElementById(`x${i}`).value);
                y[i] = parseFloat(document.getElementById(`y${i}`).value);
                if (isNaN(x[i]) || isNaN(y[i])) {
                    showResult('<span class="error">Please fill all points</span>');
                    return;
                }
            }
            
            if (isNaN(xVal)) {
                showResult('<span class="error">Please enter interpolation point</span>');
                return;
            }
            
            // Sort points by x
            const points = [];
            for (let i = 0; i < n; i++) {
                points.push({x: x[i], y: y[i]});
            }
            points.sort((a, b) => a.x - b.x);
            
            // Find interval
            let interval = -1;
            for (let i = 0; i < n - 1; i++) {
                if (xVal >= points[i].x && xVal <= points[i + 1].x) {
                    interval = i;
                    break;
                }
            }
            
            if (interval === -1) {
                showResult('<span class="error">x value is outside the data range</span>');
                return;
            }
            
            // Linear interpolation
            const x0 = points[interval].x;
            const x1 = points[interval + 1].x;
            const y0 = points[interval].y;
            const y1 = points[interval + 1].y;
            
            const yVal = y0 + (y1 - y0) * (xVal - x0) / (x1 - x0);
            
            let result = "Linear Spline Interpolation\n\n";
            result += `Using interval [${x0}, ${x1}]\n`;
            result += `Linear equation: y = ${y0.toFixed(4)} + ${((y1-y0)/(x1-x0)).toFixed(4)} × (x - ${x0})\n`;
            result += `\n✓ P(${xVal}) = ${yVal.toFixed(6)}`;
            
            showResult(result);
        }

        // Regression Methods
        function calculatePolynomialRegression() {
            const n = parseInt(document.getElementById('npoints').value);
            const degree = parseInt(document.getElementById('degree').value);
            
            const x = [], y = [];
            for (let i = 0; i < n; i++) {
                x[i] = parseFloat(document.getElementById(`x${i}`).value);
                y[i] = parseFloat(document.getElementById(`y${i}`).value);
                if (isNaN(x[i]) || isNaN(y[i])) {
                    showResult('<span class="error">Please fill all points</span>');
                    return;
                }
            }
            
            if (degree >= n) {
                showResult('<span class="error">Degree must be less than number of points</span>');
                return;
            }
            
            // Build normal equations matrix
            const m = degree + 1;
            const A = [], b = [];
            
            for (let i = 0; i < m; i++) {
                A[i] = [];
                b[i] = 0;
                for (let j = 0; j < m; j++) {
                    A[i][j] = 0;
                    for (let k = 0; k < n; k++) {
                        A[i][j] += Math.pow(x[k], i + j);
                    }
                }
                for (let k = 0; k < n; k++) {
                    b[i] += y[k] * Math.pow(x[k], i);
                }
            }
            
            // Solve using Gauss elimination
            const coeffs = solveLinearSystem(A, b);
            
            let result = `Polynomial Regression (Degree ${degree})\n\n`;
            result += "Coefficients:\n";
            
            let equation = "y = ";
            for (let i = 0; i < m; i++) {
                result += `a${i} = ${coeffs[i].toFixed(6)}\n`;
                if (i > 0) equation += " + ";
                equation += `${coeffs[i].toFixed(4)}`;
                if (i > 0) equation += `x`;
                if (i > 1) equation += `^${i}`;
            }
            
            result += `\nEquation: ${equation}\n`;
            
            // Calculate R-squared
            let yMean = 0;
            for (let i = 0; i < n; i++) {
                yMean += y[i];
            }
            yMean /= n;
            
            let ssRes = 0, ssTot = 0;
            for (let i = 0; i < n; i++) {
                let yPred = 0;
                for (let j = 0; j < m; j++) {
                    yPred += coeffs[j] * Math.pow(x[i], j);
                }
                ssRes += Math.pow(y[i] - yPred, 2);
                ssTot += Math.pow(y[i] - yMean, 2);
            }
            
            const r2 = 1 - ssRes / ssTot;
            result += `\nR² = ${r2.toFixed(6)}`;
            
            showResult(result);
        }

        function calculateMultipleLinearRegression() {
            const n = parseInt(document.getElementById('npoints').value);
            const vars = parseInt(document.getElementById('nvars').value);
            
            const X = [], y = [];
            for (let i = 0; i < n; i++) {
                X[i] = [1]; // Intercept term
                for (let j = 0; j < vars; j++) {
                    const val = parseFloat(document.getElementById(`x${i}-${j}`).value);
                    if (isNaN(val)) {
                        showResult('<span class="error">Please fill all data points</span>');
                        return;
                    }
                    X[i].push(val);
                }
                y[i] = parseFloat(document.getElementById(`y${i}`).value);
                if (isNaN(y[i])) {
                    showResult('<span class="error">Please fill all y values</span>');
                    return;
                }
            }
            
            // Calculate X'X and X'y
            const m = vars + 1;
            const XtX = [], Xty = [];
            
            for (let i = 0; i < m; i++) {
                XtX[i] = [];
                Xty[i] = 0;
                for (let j = 0; j < m; j++) {
                    XtX[i][j] = 0;
                    for (let k = 0; k < n; k++) {
                        XtX[i][j] += X[k][i] * X[k][j];
                    }
                }
                for (let k = 0; k < n; k++) {
                    Xty[i] += X[k][i] * y[k];
                }
            }
            
            // Solve normal equations
            const coeffs = solveLinearSystem(XtX, Xty);
            
            let result = "Multiple Linear Regression\n\n";
            result += "Coefficients:\n";
            result += `β₀ (intercept) = ${coeffs[0].toFixed(6)}\n`;
            
            let equation = `y = ${coeffs[0].toFixed(4)}`;
            for (let i = 1; i <= vars; i++) {
                result += `β${i} = ${coeffs[i].toFixed(6)}\n`;
                equation += ` + ${coeffs[i].toFixed(4)}×x${i}`;
            }
            
            result += `\nEquation: ${equation}\n`;
            
            // Calculate R-squared
            let yMean = 0;
            for (let i = 0; i < n; i++) {
                yMean += y[i];
            }
            yMean /= n;
            
            let ssRes = 0, ssTot = 0;
            for (let i = 0; i < n; i++) {
                let yPred = 0;
                for (let j = 0; j < m; j++) {
                    yPred += coeffs[j] * X[i][j];
                }
                ssRes += Math.pow(y[i] - yPred, 2);
                ssTot += Math.pow(y[i] - yMean, 2);
            }
            
            const r2 = 1 - ssRes / ssTot;
            result += `\nR² = ${r2.toFixed(6)}`;
            
            showResult(result);
        }

        // Integration Methods
        function calculateSingleTrapezoidal() {
            const func = document.getElementById('func').value;
            const a = parseFloat(document.getElementById('a').value);
            const b = parseFloat(document.getElementById('b').value);
            
            if (!func || isNaN(a) || isNaN(b)) {
                showResult('<span class="error">Please fill all fields</span>');
                return;
            }
            
            try {
                const fa = evaluateFunction(func, a);
                const fb = evaluateFunction(func, b);
                const integral = (b - a) * (fa + fb) / 2;
                
                let result = "Single Trapezoidal Rule\n\n";
                result += `f(${a}) = ${fa.toFixed(6)}\n`;
                result += `f(${b}) = ${fb.toFixed(6)}\n`;
                result += `h = ${(b - a).toFixed(6)}\n\n`;
                result += `Integral = h/2 × [f(a) + f(b)]\n`;
                result += `✓ Integral ≈ ${integral.toFixed(8)}`;
                
                showResult(result);
            } catch (e) {
                showResult('<span class="error">Error: ' + e.message + '</span>');
            }
        }

        function calculateCompositeTrapezoidal() {
            const func = document.getElementById('func').value;
            const a = parseFloat(document.getElementById('a').value);
            const b = parseFloat(document.getElementById('b').value);
            const n = parseInt(document.getElementById('n').value);
            
            if (!func || isNaN(a) || isNaN(b) || isNaN(n)) {
                showResult('<span class="error">Please fill all fields</span>');
                return;
            }
            
            try {
                const h = (b - a) / n;
                let sum = evaluateFunction(func, a) + evaluateFunction(func, b);
                
                let result = "Composite Trapezoidal Rule\n\n";
                result += `Interval: [${a}, ${b}]\n`;
                result += `Number of subintervals: ${n}\n`;
                result += `h = ${h.toFixed(6)}\n\n`;
                
                for (let i = 1; i < n; i++) {
                    const x = a + i * h;
                    sum += 2 * evaluateFunction(func, x);
                }
                
                const integral = h * sum / 2;
                
                result += `✓ Integral ≈ ${integral.toFixed(8)}`;
                
                showResult(result);
            } catch (e) {
                showResult('<span class="error">Error: ' + e.message + '</span>');
            }
        }

        function calculateSimpson() {
            const func = document.getElementById('func').value;
            const a = parseFloat(document.getElementById('a').value);
            const b = parseFloat(document.getElementById('b').value);
            
            if (!func || isNaN(a) || isNaN(b)) {
                showResult('<span class="error">Please fill all fields</span>');
                return;
            }
            
            try {
                const h = (b - a) / 2;
                const x1 = a + h;
                
                const fa = evaluateFunction(func, a);
                const fx1 = evaluateFunction(func, x1);
                const fb = evaluateFunction(func, b);
                
                const integral = h / 3 * (fa + 4 * fx1 + fb);
                
                let result = "Simpson's 1/3 Rule\n\n";
                result += `f(${a}) = ${fa.toFixed(6)}\n`;
                result += `f(${x1}) = ${fx1.toFixed(6)}\n`;
                result += `f(${b}) = ${fb.toFixed(6)}\n`;
                result += `h = ${h.toFixed(6)}\n\n`;
                result += `Integral = h/3 × [f(a) + 4f(mid) + f(b)]\n`;
                result += `✓ Integral ≈ ${integral.toFixed(8)}`;
                
                showResult(result);
            } catch (e) {
                showResult('<span class="error">Error: ' + e.message + '</span>');
            }
        }

        function calculateCompositeSimpson() {
            const func = document.getElementById('func').value;
            const a = parseFloat(document.getElementById('a').value);
            const b = parseFloat(document.getElementById('b').value);
            const n = parseInt(document.getElementById('n').value);
            
            if (!func || isNaN(a) || isNaN(b) || isNaN(n)) {
                showResult('<span class="error">Please fill all fields</span>');
                return;
            }
            
            if (n % 2 !== 0) {
                showResult('<span class="error">Number of intervals must be even</span>');
                return;
            }
            
            try {
                const h = (b - a) / n;
                let sum = evaluateFunction(func, a) + evaluateFunction(func, b);
                
                let result = "Composite Simpson's 1/3 Rule\n\n";
                result += `Interval: [${a}, ${b}]\n`;
                result += `Number of intervals: ${n}\n`;
                result += `h = ${h.toFixed(6)}\n\n`;
                
                for (let i = 1; i < n; i++) {
                    const x = a + i * h;
                    const fx = evaluateFunction(func, x);
                    sum += (i % 2 === 0 ? 2 : 4) * fx;
                }
                
                const integral = h * sum / 3;
                
                result += `✓ Integral ≈ ${integral.toFixed(8)}`;
                
                showResult(result);
            } catch (e) {
                showResult('<span class="error">Error: ' + e.message + '</span>');
            }
        }

        // Differentiation Methods
        function calculateForwardDifference() {
            const func = document.getElementById('func').value;
            const x = parseFloat(document.getElementById('x').value);
            const h = parseFloat(document.getElementById('h').value);
            
            if (!func || isNaN(x) || isNaN(h)) {
                showResult('<span class="error">Please fill all fields</span>');
                return;
            }
            
            try {
                const fx = evaluateFunction(func, x);
                const fxh = evaluateFunction(func, x + h);
                const derivative = (fxh - fx) / h;
                
                let result = "Forward Difference (First Derivative)\n\n";
                result += `f(x) = ${fx.toFixed(6)}\n`;
                result += `f(x+h) = ${fxh.toFixed(6)}\n`;
                result += `h = ${h}\n\n`;
                result += `f'(x) ≈ [f(x+h) - f(x)] / h\n`;
                result += `✓ f'(${x}) ≈ ${derivative.toFixed(8)}`;
                
                showResult(result);
            } catch (e) {
                showResult('<span class="error">Error: ' + e.message + '</span>');
            }
        }

        function calculateBackwardDifference() {
            const func = document.getElementById('func').value;
            const x = parseFloat(document.getElementById('x').value);
            const h = parseFloat(document.getElementById('h').value);
            
            if (!func || isNaN(x) || isNaN(h)) {
                showResult('<span class="error">Please fill all fields</span>');
                return;
            }
            
            try {
                const fx = evaluateFunction(func, x);
                const fxh = evaluateFunction(func, x - h);
                const derivative = (fx - fxh) / h;
                
                let result = "Backward Difference (First Derivative)\n\n";
                result += `f(x-h) = ${fxh.toFixed(6)}\n`;
                result += `f(x) = ${fx.toFixed(6)}\n`;
                result += `h = ${h}\n\n`;
                result += `f'(x) ≈ [f(x) - f(x-h)] / h\n`;
                result += `✓ f'(${x}) ≈ ${derivative.toFixed(8)}`;
                
                showResult(result);
            } catch (e) {
                showResult('<span class="error">Error: ' + e.message + '</span>');
            }
        }

        function calculateCentralDifference() {
            const func = document.getElementById('func').value;
            const x = parseFloat(document.getElementById('x').value);
            const h = parseFloat(document.getElementById('h').value);
            
            if (!func || isNaN(x) || isNaN(h)) {
                showResult('<span class="error">Please fill all fields</span>');
                return;
            }
            
            try {
                const fxh1 = evaluateFunction(func, x + h);
                const fxh2 = evaluateFunction(func, x - h);
                const derivative = (fxh1 - fxh2) / (2 * h);
                
                let result = "Central Difference (First Derivative)\n\n";
                result += `f(x-h) = ${fxh2.toFixed(6)}\n`;
                result += `f(x+h) = ${fxh1.toFixed(6)}\n`;
                result += `h = ${h}\n\n`;
                result += `f'(x) ≈ [f(x+h) - f(x-h)] / 2h\n`;
                result += `✓ f'(${x}) ≈ ${derivative.toFixed(8)}`;
                
                showResult(result);
            } catch (e) {
                showResult('<span class="error">Error: ' + e.message + '</span>');
            }
        }

        function calculateForwardDifferenceSecond() {
            const func = document.getElementById('func').value;
            const x = parseFloat(document.getElementById('x').value);
            const h = parseFloat(document.getElementById('h').value);
            
            if (!func || isNaN(x) || isNaN(h)) {
                showResult('<span class="error">Please fill all fields</span>');
                return;
            }
            
            try {
                const fx = evaluateFunction(func, x);
                const fxh = evaluateFunction(func, x + h);
                const fx2h = evaluateFunction(func, x + 2 * h);
                const derivative = (fx2h - 2 * fxh + fx) / (h * h);
                
                let result = "Forward Difference (Second Derivative)\n\n";
                result += `f(x) = ${fx.toFixed(6)}\n`;
                result += `f(x+h) = ${fxh.toFixed(6)}\n`;
                result += `f(x+2h) = ${fx2h.toFixed(6)}\n`;
                result += `h = ${h}\n\n`;
                result += `f''(x) ≈ [f(x+2h) - 2f(x+h) + f(x)] / h²\n`;
                result += `✓ f''(${x}) ≈ ${derivative.toFixed(8)}`;
                
                showResult(result);
            } catch (e) {
                showResult('<span class="error">Error: ' + e.message + '</span>');
            }
        }

        function calculateBackwardDifferenceSecond() {
            const func = document.getElementById('func').value;
            const x = parseFloat(document.getElementById('x').value);
            const h = parseFloat(document.getElementById('h').value);
            
            if (!func || isNaN(x) || isNaN(h)) {
                showResult('<span class="error">Please fill all fields</span>');
                return;
            }
            
            try {
                const fx = evaluateFunction(func, x);
                const fxh = evaluateFunction(func, x - h);
                const fx2h = evaluateFunction(func, x - 2 * h);
                const derivative = (fx - 2 * fxh + fx2h) / (h * h);
                
                let result = "Backward Difference (Second Derivative)\n\n";
                result += `f(x-2h) = ${fx2h.toFixed(6)}\n`;
                result += `f(x-h) = ${fxh.toFixed(6)}\n`;
                result += `f(x) = ${fx.toFixed(6)}\n`;
                result += `h = ${h}\n\n`;
                result += `f''(x) ≈ [f(x) - 2f(x-h) + f(x-2h)] / h²\n`;
                result += `✓ f''(${x}) ≈ ${derivative.toFixed(8)}`;
                
                showResult(result);
            } catch (e) {
                showResult('<span class="error">Error: ' + e.message + '</span>');
            }
        }

        function calculateCentralDifferenceSecond() {
            const func = document.getElementById('func').value;
            const x = parseFloat(document.getElementById('x').value);
            const h = parseFloat(document.getElementById('h').value);
            
            if (!func || isNaN(x) || isNaN(h)) {
                showResult('<span class="error">Please fill all fields</span>');
                return;
            }
            
            try {
                const fx = evaluateFunction(func, x);
                const fxh1 = evaluateFunction(func, x + h);
                const fxh2 = evaluateFunction(func, x - h);
                const derivative = (fxh1 - 2 * fx + fxh2) / (h * h);
                
                let result = "Central Difference (Second Derivative)\n\n";
                result += `f(x-h) = ${fxh2.toFixed(6)}\n`;
                result += `f(x) = ${fx.toFixed(6)}\n`;
                result += `f(x+h) = ${fxh1.toFixed(6)}\n`;
                result += `h = ${h}\n\n`;
                result += `f''(x) ≈ [f(x+h) - 2f(x) + f(x-h)] / h²\n`;
                result += `✓ f''(${x}) ≈ ${derivative.toFixed(8)}`;
                
                showResult(result);
            } catch (e) {
                showResult('<span class="error">Error: ' + e.message + '</span>');
            }
        }

        // Helper functions
        function determinant(matrix) {
            const n = matrix.length;
            if (n === 1) return matrix[0][0];
            if (n === 2) return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
            
            let det = 0;
            for (let j = 0; j < n; j++) {
                const minor = [];
                for (let i = 1; i < n; i++) {
                    minor[i - 1] = [];
                    for (let k = 0; k < n; k++) {
                        if (k !== j) {
                            minor[i - 1].push(matrix[i][k]);
                        }
                    }
                }
                det += Math.pow(-1, j) * matrix[0][j] * determinant(minor);
            }
            return det;
        }

        function dotProduct(a, b) {
            let sum = 0;
            for (let i = 0; i < a.length; i++) {
                sum += a[i] * b[i];
            }
            return sum;
        }

        function matrixVectorMultiply(A, x) {
            const result = [];
            for (let i = 0; i < A.length; i++) {
                result[i] = 0;
                for (let j = 0; j < x.length; j++) {
                    result[i] += A[i][j] * x[j];
                }
            }
            return result;
        }

        function solveLinearSystem(A, b) {
            const n = A.length;
            const Aug = [];
            
            for (let i = 0; i < n; i++) {
                Aug[i] = [...A[i], b[i]];
            }
            
            // Gauss elimination with partial pivoting
            for (let k = 0; k < n; k++) {
                let maxRow = k;
                for (let i = k + 1; i < n; i++) {
                    if (Math.abs(Aug[i][k]) > Math.abs(Aug[maxRow][k])) {
                        maxRow = i;
                    }
                }
                
                [Aug[k], Aug[maxRow]] = [Aug[maxRow], Aug[k]];
                
                for (let i = k + 1; i < n; i++) {
                    const factor = Aug[i][k] / Aug[k][k];
                    for (let j = k; j <= n; j++) {
                        Aug[i][j] -= factor * Aug[k][j];
                    }
                }
            }
            
            // Back substitution
            const x = new Array(n);
            for (let i = n - 1; i >= 0; i--) {
                x[i] = Aug[i][n];
                for (let j = i + 1; j < n; j++) {
                    x[i] -= Aug[i][j] * x[j];
                }
                x[i] /= Aug[i][i];
            }
            
            return x;
        }

        function showResult(content) {
            const resultDiv = document.querySelector('.result-content');
            if (resultDiv) {
                resultDiv.innerHTML = content;
            }
        }

        function showMethod(methodName) {
            currentMethod = methodName;
            const method = methods[methodName];
            
            if (!method) return;
            
            let html = '';
            
            if (methodName === 'welcome') {
                html = method.content;
            } else {
                html = `
                    <div class="method-content active">
                        <h2 class="method-title">${method.title}</h2>
                        ${method.description ? `<div class="description">${method.description}</div>` : ''}
                        <div class="input-group">
                            ${method.inputs}
                            <button class="calculate-btn" onclick="methods['${methodName}'].calculate()">Calculate</button>
                        </div>
                        <div class="result-area">
                            <div class="result-title">Result</div>
                            <div class="result-content">Results will appear here...</div>
                        </div>
                    </div>
                `;
            }
            
            document.getElementById('contentArea').innerHTML = html;
            
            // Initialize method if needed
            if (method.init) {
                method.init();
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Add click handlers to all method buttons
            document.querySelectorAll('.method-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    // Remove active class from all buttons
                    document.querySelectorAll('.method-btn').forEach(b => b.classList.remove('active'));
                    // Add active class to clicked button
                    this.classList.add('active');
                    // Show the method
                    showMethod(this.dataset.method);
                });
            });
            
            // Show welcome screen
            showMethod('welcome');
        });
    </script>
</body>
</html>